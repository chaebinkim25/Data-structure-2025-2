지난 시간에 했던 큐는, 데이터 여러개를 추가해 놓은 다음에 하나를 꺼내면, 가장 먼저 추가했던 데이터가 꺼내지는 자료구조였어요. 배열이나 링크드 리스트로 구현했을 때, 한쪽 끝에서 데이터를 추가하면, 데이터가 삭제되는 쪽은 그 반대쪽인 특징이 있었어요.


그래서 지난 시간에 링크드 리스트와 배열로 큐를 구현해 봤고, 특히 배열로 큐를 구현할 때는 간단하게 하는 방법과, 원형으로 구현하는 방법을 봤어요. 그리고 예제로 스택에 이어서 미로찾기를 해봤어요. 

오늘은 C 코드로 만든 것을 볼거에요. 


오늘도 include할 헤더로 입출력을 위한 stdio.h와, 메모리 관련 기능을 위한 stdlib.h를 써요. 


오늘의 첫번째 순서는 링크드 리스트로 구현한 큐에요. 

코드를 간단하게 하기 위해서 방식을 조금 바꿨어요. front가 가리키는 노드가, 원래는 첫번째 데이터 노드였지만, 이번에는 첫번째 데이터의 이전 노드로 해볼게요. front의 초기값으로는 더미 노드를 써요. 이렇게 하면 front는 항상 존재해서, 따로 NULL인지 체크를 해주지 않아도 되요. 큐가 비어있을 때는, front의 next가 NULL이고, rear가 가리키는 마지막에 추가된 노드는 front가 가리키는 노드와 같아요. 그래서 rear도 초기값만 front와 같게 해두면, NULL인지 따로 확인하지 않아도 되요. 

그래서 링크드 리스트로 구현한 큐의 구조체에서, front는 최근에 큐에서 꺼낸 노드, rear는 최근에 큐에 추가된 노드에요. 그리고 데이터 개수를 구하는 수고를 덜기 위해서, size도 멤버로 썼어요. front와 rear의 초기값은 같은 더미 노드를 쓰고, size의 초기값은 0이에요. 

주요 기능을 보면, 데이터를 추가하고 삭제하는데, 이름의 앞에 링크드 리스트 큐라는 의미의 LQUEUE를 붙였어요. 그래서 LQUEUE_ENQUEUE는 새로운 노드를 rear 뒤에 연결하고, rear를 업데이트 해요. LQUEUE_DEQUEUE는 front를 업데이트 하고, 이전 front를 삭제하고, 데이터를 반환해요.


