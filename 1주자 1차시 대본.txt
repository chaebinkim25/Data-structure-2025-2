이 동영상에서는 자료구조와 리스트, 배열리스트에 대해 설명드려요.




자료구조는 데이터를 어떻게 담고, 꺼내고, 바꿀 것인지에 대한 체계적인 설계도예요.
프로그램의 목적에 따라 자료구조에 요구되는 기능이 달라져요.

예를 들어, 할 일을 저장할 때는 일 정보를 하나씩 저장하고, 정해놓은 규칙에 따라 하나씩 꺼낼 수 있으면 되요.
수학 문제를 풀기 위해 다항식을 저장할 때는 항이 지수에 따라 정렬되어 있어야 하고, 모든 항의 정보를 확인할 수 있어야 되요.
계산을 하기 위해 수식을 저장할 때는 어떤 순서로 계산을 할지에 대한 정보까지 저장되어 있어야 되요.

초기 프로그래머들은 알려진 코드가 많지 않았기 때문에 필요할 때마다 직접 자료구조를 만들었어요. 
시간이 지나면서 많은 사람들이 비슷한 문제를 풀며 최적화된 패턴을 발견했고, 그것들이 교과서로 정리되었죠.
우리는 그 축적된 지식 위에서 올바른 선택과 구현 요령을 배우게 되요.





강의는 이론 및 예제 -> C 프로그램 구현의 흐름으로 진행돼요. 

교과서는 Fundamentals of Data Structures in C로 우리 학교 소웨과에서 전통적으로 쓰여오던 교과서예요. 

그리고 몇 년 전에 소웨과에서 한 자료구조 강의 영상이 학교 홈페이지 MOCA의 자료구조 모듈에 올라가 있어요. 

이번 학기 강의에서 핵심 개념과 실습 코드의 뼈대를 잡아드리니, 부가 설명이나 다른 관점의 해석이 필요할 때 MOCA 자료를 병행해서 보세요. 

운영 방식은 매주 하나의 주제를 깊게 파고들어요. 

화요일에는 동작 원리와 시간 효율, 공간 효율을 다루고, 금요일에는 이를 C 코드로 구현해요. 



강의 로드맵은 한 달에 한 묶음씩으로 설계되어 있어요. 

9월에 다룰 내용은 일차원 선형 구조예요. 데이터 간의 관계가 앞뒤 관계만 있어요.

10월에는 계층 정보를 저장할 수 있는 구조를 다뤄요. 데이터 간의 관계는 부모 자식 관계이고, 이를 통해 모든 데이터들이 이어져 있어요. 최초 조상에 해당하는 하나를 제외한 나머지 전체가 부모 데이터를 가지고 있어요.

11월에는 연결 제약이 거의 없는 그래프에 대해 배워요. 

그리고 남은 기간 동안에 탐색 최적화 관련된 자료 구조를 다뤄요. 



9월 한달은 데이터가 줄지어 있는 형태의 자료 구조를 다뤄요. 

먼저 1주차, 2주차에는 모든 데이터에 접근할 수 있는 리스트에 대해서 배워요. 

1주차에는 메모리의 한 부분을 나눠놓은 배열을 써서 리스트를 간편하게 구현해요. 

2주차에는 모든 데이터에 다음 데이터 주소를 저장하는 방식으로 리스트를 구현해요.  

3주차, 4주차에는 데이터 접근 순서를 정해 놓아서 더 효율적인 자료 구조를 배워요.



10월달에는 계층이라는 차원이 더 추가된 자료 구조를 다뤄요. 

5주차에는 하나의 뿌리에서 뻗어나가는 식으로 연결되어 부모-자식-형제로 공간이 확장된 트리 자료 구조를 다뤄요. 

중간에 개천절, 추석 연휴로 일주일을 쉬고, 

6주차에는 트리의 뿌리에서 멀수록 값이 작거나 큰 성질을 유지해서 최소값이나 최대값을 빠르게 찾을 수 있는 구조를 다뤄요. 

그리고 나서 중간고사를 보고, 

7주차에 리스트의 데이터를 정렬하는 다양한 방법을 다뤄요. 



11월달에는 데이터들을 자유롭게 연결할 수 있는 자료구조와 여기서 최단경로 계산, 트리로의 변환법을 3주 동안 다뤄요. 

그리고 남은 기간 동안에 탐색에 관련된 자료구조를 배워요.

11주차에는 값과 인덱스를 매핑하는 방법을 통해 값에 해당하는 데이터를 배열에서 찾을 수 있는 구조를 배워요.



12월달 12주차에는 모든 노드에서 왼쪽 자손들이 자신보다 작은 값을 가지고, 오른쪽 자손들은 자신보다 큰 값을 가지는 이진탐색트리를 해요.

13주차에는 항상 균형을 이루고 있어 빠른 탐색이 보장되는 레드블랙트리를 해요.

그리고 마지막 주에 기말고사를 봐요



평가 방식은 출석과 과제가 각각 15%씩, 중간고사와 기말고사가 각각 35%씩이에요.

출석은 미니 퀴즈 제출 여부로 체크해요. 수업 내용을 확인하는 형식으로 성적에 비중은 없지만 동점자 조정에 반영돼요.

과제는 C로 구현하는 프로그래밍 과제예요.

시험은 PPT 슬라이드에서 출제돼요. 



리스트는 데이터들이 순서를 가지고 일렬로 놓여 있는 것을 뜻해요.

수업 설명의 편의상 1번부터 순서를 매겨요.

핵심은 k번째 데이터라는 개념이 항상 의미가 있다는 점이에요. 그래서 위치 기반으로 기능할 수 있어요. 

INSERT(k, x)는 k번째 위치에 데이터 x를 추가해요. 기존의 k, k+1, ... 번째 원소들은 k+1, k+2, ... 번째가 되요.

DELETE(k)는 k번째 원소를 삭제해요. 기존의 k+1, k+2, ... 번째 원소들이 k, k+1, ... 번째가 되요.

RETRIEVE(k)는 k번째 원소를 반환해요.



배열 리스트는 리스트의 데이터를 배열에 저장해서 구현하는 자료구조예요.

데이터는 배열에 순서대로 저장하고, 현재 저장된 개수와 최대 저장 개수를 별도로 기록해요.

배열 리스트를 초기화 하면, 최대 저장 개수는 정해진 값이 되고, 저장된 데이터 수는 0이 되고, 최대 저장 개수 만큼 저장 가능한 배열이 만들어져요. 

저장된 데이터 수는 데이터를 추가할 때마다 증가하고, 데이터를 삭제할 때마다 감소해요. 

최대 저장 개수는 배열이 바뀌지 않는 한 초기화 후부터 그대로 유지돼요.



배열에서 인덱스는 편의상 1부터 시작해요. 그래서 배열 크기는 capacity+1로 만들고, 인덱스 0은 비워둬요.

다른 종류의 자료구조를 할 때 1부터 인덱스를 시작하는 것이 좋을 때가 있기 때문에, 이번 강의에서 항상 인덱스를 1부터 시작해요.





이제 배열 리스트를 실제로 만드는 단계예요. INITIALIZE는 초기화를 해서 배열 리스트를 쓸 수 있게 준비하는 작업이에요.

파라미터로는 초기화할 배열 리스트 A와 최대 용량으로 설정할 값 cap을 받아요.

작업을 하는데 문제가 없으려면 cap이 0보다 커야 해요.

하는 일은 A의 배열(data)를 cap + 1 크기로 마련하고, 

A의 원소 수(size)를 0으로 설정하고, 

A의 최대 용량(capacity)를 cap으로 설정해요.




다음은 배열 리스트에 값을 추가하는 기능, INSERT(A, k, val)이에요.

A는 배열 리스트, k는 데이터가 추가될 위치, val은 추가될 데이터예요.

작업을 하기 전에 확인할 것은, k가 적절한 위치에 있는지, A의 배열에 추가할 자리가 있는지예요.

추가하기 전에 size개 있었으면, 추가한 후에는 size + 1개 이므로, 적절한 k는 1부터 size + 1개까지예요.

그리고 A의 배열에 추가하려는 자리가 있으려면 size가 capacity보다 작아야 해요.

동작은 k번째를 포함해서 그 이후의 데이터를 모두 오른쪽으로 한 칸 이동하고, k 자리에 val을 대입하고, size를 하나 늘려요.

이동할 때 순서는 제일 끝 데이터부터 이동해요.

k번째 데이터부터 이동하면 모든 데이터가 k번째 데이터가 되는 현상이 발생해요. 

이동이 끝나면 저장된 데이터 개수가 하나 증가했으니 size의 값을 하나 증가시켜요.




INSERT를 하는데 시간이 얼마나 드는지를 볼게요. 

size는 증가만 한번 시키면 되고, data 배열에 값을 대입하는데 주로 시간이 쓰이기 때문에 대입을 몇번 하는지가 중요해요.

k가 1일 때 모든 데이터를 한 칸 뒤로 보내야 하기 때문에 대입을 가장 많이 해요.

기존 데이터를 이동하는데 n번, 새로운 데이터를 저장하는데 1번 대입을 해서 총 n+1번 대입을 해요.

k가 size + 1일 때는 기존 데이터를 이동하지 않으므로 총 1번 대입을 해요.

평균을 내보면, size를 n이라고 했을 때, 1부터 n+1까지 더하면 (n+1)(n+2)/2가 되고, n+1로 나누면 (n+2)/2가 되서 n에 비례하게 되요.




DELETE(A, k)는 배열 리스트 A에서 k번째 데이터를 삭제하는 기능이에요.

삭제 가능한 위치 k는 첫번째 데이터에 해당하는 1부터 마지막 데이터에 해당하는 size까지 예요.

또한 삭제가 가능할 조건은 저장된 데이터가 있는 것으로 size가 0보다 큰 것이에요.

동작은 삭제할 데이터의 다음 데이터부터 모든 데이터를 한 칸 왼쪽으로 이동해요.

삭제한 후 size는 1 감소해요.



DELETE의 동작을 봤으니, 시간이 얼마나 드는지를 따져볼게요.

핵심은 k 다음 원소들을 몇개 앞으로 당겨야 하느냐예요.

최악의 경우는 k가 1일 때 맨 앞의 원소를 지워서 2부터 size까지를 전부 앞으로 이동시켜서 배열에 size - 1번 대입이 발생해요.

최선의 경우는 k가 size일 때 맨 뒤의 원소를 지워서 배열이 일어나지 않아요.

평균적으로는, size를 n으로 두면, n-1부터 0까지 더한 다음에 n으로 나누면, n-2/2가 되어서 n에 비례해요.




RETRIEVE(A, k)는 배열 리스트 A에서 k번째 데이터를 반환해요.

여기서도 k는 데이터 위치 범위인 1부터 size까지이고, 조건은 size가 0보다 큰 것이에요.

동작은 A.data 배열에서 k번째 데이터를 반환해요.




RETRIEVE(A, k)에 드는 시간은 메모리 주소를 계산해서 배열에서 데이터를 꺼내오는 상수시간이에요. 

여기까지 최대 저장량이 정해져 있는 고정 크기 배열 리스트에 대해서 알아봤어요. 

다음으로 최대 저장량을 바꿀 수 있는 가변 크기 배열 리스트를 볼게요. 




가변 크기 배열 리스트는 최대 저장량이 꽉 찼을 때 최대 저장량을 늘려서 INSERT의 제약 조건을 풀어요.

INSERT하려는데 자리가 없으면, 더 큰 배열을 새로 만들고 기존 데이터를 복사하고, 그다음에 원래 INSERT를 그대로 수행해요. 

전체 데이터를 복사하기 때문에 가끔 비싸지만 대부분 복사가 되지 않아서 빨라요. 




배열을 새로 만들어서 기존 데이터를 복사하는 함수가 RESIZE예요. 

새 배열을 만들고, 기존 데이터를 전부 복사하고, A의 data를 새 배열로 교체하고, A의 capacity를 업데이트해요.




RESIZE를 써서 가변 크기 형식으로 배열 리스트에 데이터를 추가하는 함수가 INSERT_VAR(A, k, x)이에요. 

고정 크기 형식으로 추가할 때는 배열에 자리가 없으면 동작을 하지 않았었는데, 

가변 크기 형식으로 추가할 때는 배열에 자리가 없으면 먼저 RESIZE해서 자리를 만들고, 고정 크기 형식으로 추가해요. 




가변 크기 형식으로 데이터를 추가하면서 RESIZE에 시간을 어느정도 썼는지 계산해볼게요. 

RESIZE를 항상 하는 것이 아니기 때문에 평균적으로 쓴 시간을 계산할게요. 

저장된 데이터가 없을 때부터 추가를 해서 데이터가 n개 있을 때 추가할 때까지 RESIZE에서 복사한 총 횟수를 계산해요.

n개에서 배열이 꽉차서 RESIZE를 했다고 가정하면, 복사된 횟수가 n번 이에요.

용량이 가득 찰 때마다 r배로 증가시키고 있다고 하면, 이전 RESIZE는 데이터가 n/r개일때 해서 복사를 n/r번 했어요.

n이 아주 크다고 가정해서 n/r은 정수라고 볼게요. 

그 이전 RESIZE는 데이터 개수가 n/r^2에서 했고, n이 크다고 했으니 거의 무한 등비 수열이 되요.

그래서 복사된 총 횟수 합계를 구해보면 r / (r - 1) * n이 되요.

데이터가 0개 있을 때부터 n개 있을때 까지 추가했으면 총 n + 1번 추가를 했으니까, 

추가할 때마다 RESIZE에서 대입한 횟수는 평균 r / (r - 1)로 상수 횟수가 되요. 




앞에서 RESIZE를 할 때마다 크기를 두배씩 증가시켰는데, 그 근거를 효율 측면에서 찾아보려고 해요.

데이터가 n개 있을 때 추가를 하면, 대입 횟수는 r / (r - 1) * n였어요. 

최종적으로 쓰고 있는 메모리의 크기는 r * n이에요. 

대입 횟수와 메모리의 크기를 곱해서 시공간 효율을 나타내는 지표를 만들어봐요.

배율이 3배일 때, 복사횟수는 1.5 n, 메모리 크기는 3 n으로, 지표는 4.5 n^2가 돼요.

배율이 2배일 때, 복사횟수는 2 n, 메모리 크기는 2 n으로, 지표는 4 n^2가 돼요

배율이 1.5배일 때, 복사횟수는 3 n, 메모리 크기는 1.5 n으로, 지표는 4.5 n^2가 돼요.

비교해보면, 배율이 2배일 때 지표가 최소예요.

미분을 해서도 최소를 확인해볼 수 있어요. 

지표가 r^2 / (r - 1) * n^2 인데, r로 미분하면 ( 2r (r - 1) - r^2 ) / (r - 1) * n^2으로, 

정리하면, r (r - 2) / (r - 1) * n^2을 가져서, 극값이 r = 2가 되요. 

여기까지 가변 크기 배열 리스트였고, 다음으로 다항식 예제를 하나 풀어볼꼐요.




2x^2 + 3x^1 같은 다항식을 항별로 리스트에 저장해 볼게요.

항에는 정보가 계수와 지수가 있으므로, 배열 리스트를 만들 때, 계수 배열과 지수 배열을 만들어 봐요.

계수 배열은 coeff에 저장하고, 지수 배열은 exp에 저장해요.

size와 capacity는 앞에서와 동일하게 저장된 데이터 수와 최대 저장량을 기록해요.





항 리스트의 초기화 기능 INITIALIZE는 고정 크기 리스트에서와 다르게

cap + 1 크기의 새로운 배열 두개를 만들어서 coeff와 exp에 저장해요.

또한 자주 쓸 자료구조가 아니고, 문제를 풀기 위한 일회용이기 때문에 별도로 체크는 하지 않을게요.

capacity에는 cap을 저장하고, size에는 0을 저장해요.




항 리스트의 추가 기능 INSERT도 확인 작업 없이 바로 기능을 수행해요.

마지막 데이터 A.size번째부터 k번째까지

coeff, exp에서 한 칸 오른쪽에 복사해요.

새로운 데이터를 k번째 위치에 복사하고, 

size를 1 증가시켜요.




방금 정한 두 기능을 써서 다항식 덧셈을 하는 기능을 만들어볼게요.

ADD라는 이름의 기능이고, 항 리스트 X, Y를 매개변수로 받아요.

X, Y에서 항이 지수의 내림차순으로 정렬되어 있다고 가정하고, 덧셈의 결과도 정렬해놓아요.

먼저 하는 일은 결과를 저장할 새로운 항 리스트를 만들어서 A에 저장하는 것이에요.

그리고 A를 초기화하는데, 크기는 가능한 최대 크기인 X의 항 개수 + Y의 항 개수로 해요.

다항식 덧셈을 할 때 X와 Y의 모든 항을 처리해야 하므로, 반복을 해야 해요.

X에서 처리할 항의 위치를 iX, Y에서 처리할 항의 위치를 iY라고 하고, 1을 저장해놓아요.

iX가 X.size 이하고, iY가 Y.size 이하여서 X와 Y 모두에 처리할 항이 남아있을 동안 반복해요.




반복하면서 할 일은 X에서 처리중인 항과 Y에서 처리중인 항의 지수를 비교한 결과에 따라 달라져요.

X의 iX번째 항의 지수가 Y의 iY번째 항의 지수보다 크면, 

A에 X의 iX번째 항을 추가하고, 

iX가 처리됐으니 값을 하나 증가시키고, 

반복의 시작으로 이동해요.




반대로 Y의 iY번째 항의 지수가 X의 iX번째 항의 지수보다 크면, 

A에 Y의 iY번째 항을 추가하고, 

iY가 처리됐으니 값을 하나 증가시키고, 

반복의 시작으로 이동해요.





X의 iX번째 항의 지수와 Y의 iY번째 항의 지수가 같으면, 

두 항의 계수를 더해서 새로운 계수를 계산해요.

A에는 새로운 계수와 공통된 지수에 해당하는 항을 추가해요, 

iX와 iY가 모두 처리됐으니 값을 하나 증가시키고, 

반복의 시작으로 이동해요.




반복이 끝나면 X나 Y중 최소 하나는 모든 항이 처리돼요.

남은 항들은 A에 모두 추가해요.

iX가 X의 size 이하면, X에 남은 항들이 있어요.

그 때는 i를 iX부터 X.size까지 반복하면서 X의 항을 모두 A에 추가해요.




iY가 Y의 size 이하면, Y에 남은 항들이 있어요.

그 때는 i를 iY부터 Y.size까지 반복하면서 Y의 항을 모두 A에 추가해요.

그리고 다 됐으면 A를 반환해요.




오늘 강의를 요약하면, 

고정 크기의 배열 리스트에서 데이터 추가, 삭제를 했고,

가변 크기 배열 리스트에서 데이터 추가도 했어요.

그리고 다항식 덧셈을 해봤어요.

다음 시간에는 오늘 한 내용을 C 언어로 구현해 볼게요.